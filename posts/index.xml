<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Example Site</title>
        <link>https://example.com/posts/</link>
        <description>Recent content in Posts on Example Site</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <copyright>Example Person</copyright>
        <lastBuildDate>Tue, 13 Aug 2024 17:12:58 +0800</lastBuildDate><atom:link href="https://example.com/posts/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Sol</title>
        <link>https://example.com/posts/sol/</link>
        <pubDate>Tue, 13 Aug 2024 17:12:58 +0800</pubDate>
        
        <guid>https://example.com/posts/sol/</guid>
        <description>&lt;p&gt;另外，点分治，边分治都可以在 $O(n\log^2 n)$ 的时间内解决这档问题，其原理与 dsu 类似。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>My First Post</title>
        <link>https://example.com/posts/my-first-post/</link>
        <pubDate>Tue, 13 Aug 2024 16:19:21 +0800</pubDate>
        
        <guid>https://example.com/posts/my-first-post/</guid>
        <description>&lt;h3 id=&#34;t1-旅行&#34;&gt;T1 旅行
&lt;/h3&gt;&lt;p&gt;给出 $n$ 个点 $m$ 条边的有向图，点有点权，边有边权。&lt;/p&gt;
&lt;p&gt;定义一条路径的权值为路径上点权的最大值乘上边权之和。&lt;/p&gt;
&lt;p&gt;求出 $s$ 到 $t$ 的路径的最小权值，$q$ 组询问，若无法到达则输出 $-1$。&lt;/p&gt;
&lt;p&gt;$1\le n\le 500,0\le m\le n\times(n-1),1\le q\le 10^4,1\le a_i,w\le 10^6,s_i\not=t_i$，保证图中不含重边与自环。&lt;/p&gt;
&lt;h4 id=&#34;subtask-16-30pts&#34;&gt;Subtask 1~6 30pts
&lt;/h4&gt;&lt;p&gt;直接搜索所有可能的路径，记录当前路径中点权最大值和边权之和。&lt;/p&gt;
&lt;p&gt;注意到非简单路径一定是不优的，因此时间复杂度为 $O(n!)$，经过合适的剪枝似乎可以多跑过一个点。&lt;/p&gt;
&lt;h4 id=&#34;subtask-78-10pts&#34;&gt;Subtask 7~8 10pts
&lt;/h4&gt;&lt;p&gt;所有 $a_i$ 均为 $1$，这就表明了所有路径的点权最大值都是 $1$，此时只需要求出 $s$ 到 $t$ 的最短路径长度。&lt;/p&gt;
&lt;p&gt;&lt;del&gt;（不会有人真的做 $n$ 次 dij 吧）&lt;/del&gt;&lt;/p&gt;
&lt;h4 id=&#34;subtask-&#34;&gt;Subtask ???
&lt;/h4&gt;&lt;p&gt;使用各种神秘的最短路做法应该可以解决稀疏图和 $n\le 50$ 的情况，&lt;del&gt;请各位充分发挥自己的想象力&lt;/del&gt;&lt;/p&gt;
&lt;h4 id=&#34;subtask-920-60pts&#34;&gt;Subtask 9~20 60pts
&lt;/h4&gt;&lt;p&gt;考虑使用 &lt;code&gt;floyd&lt;/code&gt; 算法，一个常见的算法实现为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;dis&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;min&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dis&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dis&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dis&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;其中 $k$ 每一轮做完之后，&lt;code&gt;dis[i][j]&lt;/code&gt; 表示从 $i$ 到 $j$，只经过（不包含 $i,j$）编号 $\le k$ 的中间节点的最短路径长度。&lt;/p&gt;
&lt;p&gt;这里 $k$ 的枚举顺序可以进行调整，从而控制路径中间节点的一些信息。&lt;/p&gt;
&lt;p&gt;因此考虑按点权从小到大的顺序枚举 $k$，那么&lt;code&gt;dis[i][j]&lt;/code&gt; 表示从 $i$ 到 $j$，只经过（不包含 $i,j$）点权 $\le a[k]$ 的中间节点的最短路径长度，这也就相当于中间节点的点权 $\max\le a[k]$，问题就解决了。&lt;/p&gt;
&lt;h3 id=&#34;t2-极好的树&#34;&gt;T2 极好的树
&lt;/h3&gt;&lt;p&gt;定义一棵有根树是好的，当且仅当父节点编号小于子节点编号，且没有一棵子树的大小为给定的 $k$ 个数之一。求出 $n$ 个点的每种树高的好有根树个数，$\bmod (10^9+7)$。&lt;/p&gt;
&lt;p&gt;$1\le T\le 5,0\le k&amp;lt;n\le 500$，$1\le L\le R\le n$，$2\le a_1,a_2,\cdots a_k\le n$，且所有 $a_i$ 互不相同。&lt;/p&gt;
&lt;h4 id=&#34;subtask-15-25pts&#34;&gt;Subtask 1~5 25pts
&lt;/h4&gt;&lt;p&gt;由于每个点的父节点编号小于自身编号，可知节点 $1$ 一定为根节点以及 $fa_i&amp;lt;i$，对每个 $i$ 枚举所有可能性，暴力所有树形进行统计即可。&lt;/p&gt;
&lt;h4 id=&#34;subtask-68-15pts&#34;&gt;Subtask 6~8 15pts
&lt;/h4&gt;&lt;p&gt;相当于求出树高 $h$ 分别为 $1,2,3$ 的答案。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$h=1$ 当且仅当 $n=1$ 时有一个，其他没有。&lt;/li&gt;
&lt;li&gt;$h=2$ 均有 $1$ 个（以 $1$ 为根的菊花）（需要满足无 $a_i=n$）。&lt;/li&gt;
&lt;li&gt;$h=3$ 的情况，背包第二层的子树大小即可，但是注意到直接背包无法保证树高一定为 $3$，因此求出的实际上是树高 $\le 3$ 的答案，需要减去 $h=2$ 的答案。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中间的部分分给的比较混沌，我不清楚是否有针对性的做法。&lt;/p&gt;
&lt;h4 id=&#34;subtask-920-60pts-1&#34;&gt;Subtask 9~20 60pts
&lt;/h4&gt;&lt;p&gt;根据上面部分分得到的启示，我们实际上无法很好地控制树高&lt;strong&gt;恰好&lt;/strong&gt;为 $h$，我们可以控制的是树高&lt;strong&gt;不大于&lt;/strong&gt; $h$，从这个方面进行思考，设 &lt;code&gt;dp[i][j]&lt;/code&gt; 表示 $i$ 个节点的树高 $\le j$ 的好树个数，那么若 $i$ 出现在了给出的 $k$ 个数中，则 &lt;code&gt;dp[i][j]=0&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;那么显然 $1$ 号节点为根，对 $i=1$ 的情况，只有 &lt;code&gt;dp[1][1]=1&lt;/code&gt;，对更大的 $i$，&lt;strong&gt;显然 $2$ 号节点为 $1$ 号节点的一个儿子&lt;/strong&gt;。枚举 $2$ 号节点所处的子树的大小 $k$，可以得到转移如下：
$$
dp[k][j-1]\times dp[i-k][j]\times \binom{i-2}{k-1}\rightarrow dp[i][j]
$$
如果不枚举 $2$ 所在子树的大小，而是直接 $\Large\binom{i-1}{k}$ 的话会算重。&lt;/p&gt;
&lt;p&gt;其意义为：&lt;/p&gt;
&lt;p&gt;组合数 $\Large\binom{i-2}{k-1}$ 为从编号 $3,4,\cdots ,i$ 中取出 $k-1$ 个作为 $2$ 子树中的节点的编号。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dp[k][j-1]&lt;/code&gt; 则显然是枚举了 $2$ 所处的子树大小 $k$，同时这棵子树的树高应当 $\le j-1$。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dp[i-k][j]&lt;/code&gt; 是去掉了 $2$ 的子树的剩余部分，这部分可以作为一个子问题，继续枚举其中编号最小的儿子，同时这部分的树高应当 $\le j$。&lt;/p&gt;
&lt;p&gt;最终树高为 $h$ 的答案即为 &lt;code&gt;dp[n][h]-dp[n][h-1]&lt;/code&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;另外，可以使用卷积将复杂度优化至 $O(n^2\log n)$，但在 NOIP 范围内意义不大了。&lt;/p&gt;
&lt;h3 id=&#34;t3-约束&#34;&gt;T3 约束
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;$0\le x\le m$&lt;/li&gt;
&lt;li&gt;$x\not \equiv b_i \pmod {a_i}$，对任意 $1\le i\le n$ 成立&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;求出满足条件的 $x$ 的个数。&lt;/p&gt;
&lt;p&gt;$1\le n\le 100,0\le m\le 10^{18},2\le a_i\le 31,0\le b_i&amp;lt;a_i$，所有 $a_i$ 均为质数。&lt;/p&gt;
&lt;h4 id=&#34;subtask-14-20pts&#34;&gt;Subtask 1~4 20pts
&lt;/h4&gt;&lt;p&gt;直接枚举即可&lt;/p&gt;
&lt;h4 id=&#34;subtask-58-20pts&#34;&gt;Subtask 5~8 20pts
&lt;/h4&gt;&lt;p&gt;考虑容斥，钦定若干组 $(a_i,b_i)$ 要求 $x\equiv b_i\pmod {a_i}$，其余无所谓。&lt;/p&gt;
&lt;p&gt;由于所有 $a_i$ 互不相同，因此限制至多只有 $11$ 组，可以暴力 $2^{11}$ 枚举所有钦定的情况。&lt;/p&gt;
&lt;p&gt;那么现在问题就是：&lt;del&gt;CRT 还记得吗&lt;/del&gt;。&lt;/p&gt;
&lt;p&gt;这里我们尝试两两合并同余式：
$$
\begin{aligned}
&amp;amp;a&amp;rsquo;=a_1a_2\
&amp;amp;b&amp;rsquo;=(b_1\times a_2\times (a_2^{-1}\bmod a_1)+b_2\times a_1\times (a_1^{-1}\bmod a_2))\pmod {a&amp;rsquo;}
\end{aligned}
$$
然后就可以将钦定的所有同余式合并起来得到 $x\equiv B\pmod A$，求出 $0\sim m$ 中满足这个条件的个数是容易的，记得乘上容斥系数 $(-1)^{|S|}$。&lt;/p&gt;
&lt;p&gt;你可能需要比较细心的实现，防止乘法爆 &lt;code&gt;long long&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&#34;subtask-913-25pts&#34;&gt;Subtask 9~13 25pts
&lt;/h4&gt;&lt;p&gt;这里不保证 $a_i$ 互不相同了，也就是说同一个 $a_i$ 可以对应多个 $b_i$，钦定的所有 $(a_i,b_i)$ 中 $a_i$ 一定互不相同（注意 &lt;code&gt;pair(a[i],b[i])&lt;/code&gt; 可能是相同的，此时需要去重，否则会重复计算）。&lt;/p&gt;
&lt;p&gt;此时仍然沿用上面的容斥思路是没有问题的，但是不能暴力枚举所有钦定的情况。&lt;/p&gt;
&lt;p&gt;所以考虑 &lt;code&gt;dp&lt;/code&gt;，按&lt;strong&gt;每种&lt;/strong&gt; $a_i$ 进行 &lt;code&gt;dp&lt;/code&gt;，注意到 $2\times 3\times 5\times 7\times 11\times 13\times 17=510510$，所以可以直接把合并得到的同余式中的 $B$ 作为状态存下来。&lt;/p&gt;
&lt;p&gt;设 &lt;code&gt;dp[i][j]&lt;/code&gt; 表示决策完前 $i$ 种模数，获得的同余式 $x\equiv j\pmod {L_i}$ 的答案，其中 $L_i$ 为前 $i$ 个质数的乘积，也就是合并得到的同余式的模数。&lt;/p&gt;
&lt;p&gt;对于一种 $a_i$，枚举钦定了哪一组 $(a_t,b_t)$ 违反了，然后进行转移：
$$
dp[i][j]\times (-1)\rightarrow dp[i+1][\operatorname{trans}(j,L_i,b_t,a_t)]
$$
其中 &lt;code&gt;trans&lt;/code&gt; 就是合并完两个同余式之后得到的 $B$。&lt;/p&gt;
&lt;p&gt;特殊地，如果一个质数没有钦定它违反任何一组，那么其实也需要更新（设 $P_i$ 为第 $i$ 个质数）：
$$
dp[i][j]\rightarrow dp[i+1][L_i\times t+j](0\le t&amp;lt;P_{i+1})
$$
这样就可以进行 &lt;code&gt;dp&lt;/code&gt; 了。&lt;/p&gt;
&lt;h4 id=&#34;subtask-1420-35pts&#34;&gt;Subtask 14~20 35pts
&lt;/h4&gt;&lt;p&gt;尝试沿用上面的思路，但 $2\times3\times5\times7\times11\times13\times17\times19\times23\times29\times31=200560490130$，所以直接把 $B$ 塞到状态里显然是做不到了。&lt;/p&gt;
&lt;p&gt;所以可以使用 meet in the middle，将 $11$ 种模数分成 $2,3,5,7,11,13,17$ 和 $19,23,29,31$ 两组，第一组的积为 $510510$，第二组的积为 $392863$，可以两组单独做，然后试试将它们合并起来。&lt;/p&gt;
&lt;p&gt;首先设左右两组的 &lt;code&gt;dp&lt;/code&gt; 已经全部完成，得到 &lt;code&gt;dpL&lt;/code&gt;，&lt;code&gt;dpR&lt;/code&gt;，并设 $W_1,W_2$ 分别为左右两组质数的积。&lt;/p&gt;
&lt;p&gt;那么如果左右两侧分别枚举 $i,j$，那么合并结果应当为：
$$
\begin{aligned}
&amp;amp;W&amp;rsquo;=W_1W_2\
&amp;amp;B&amp;rsquo;=(i\times W_2\times (W_2^{-1}\bmod W_1)+j\times W_1\times (W_1^{-1}\bmod W_2))\pmod {W&amp;rsquo;}
\end{aligned}
$$
同时贡献为 &lt;code&gt;dpL[i]*dpR[j]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这里的 $W_2\times (W_2^{-1}\bmod W_1)$ 和 $W_1\times (W_1^{-1}\bmod W_2)$ 都是常数，设为 $X,Y$，那么
$$
B&amp;rsquo;=(i\times X+j\times Y)\bmod {W&amp;rsquo;}
$$
还是不够简洁！设 $i&amp;rsquo;=i\times X\bmod W&amp;rsquo;,j&amp;rsquo;=j\times Y\bmod W&amp;rsquo;$，那么
$$
B&amp;rsquo;=(i&amp;rsquo;+j&amp;rsquo;)\bmod W&#39;
$$
由于 $0\sim m$ 中满足 $x\equiv B\pmod A$ 的 $x$ 个数要么为 $\lfloor m/A\rfloor$ 要么为 $\lfloor m/A\rfloor+1$，区分依据就是 $B$ 和 $m\bmod A$ 的大小关系，因此考虑分讨这两种情况，方便起见，令 $m&amp;rsquo;=m\bmod W&amp;rsquo;$。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$B&amp;rsquo;\le m&amp;rsquo;$，此时为 $\lfloor m/A\rfloor+1$ 次，这种情况，先枚举一个 $i&amp;rsquo;$，那么合法的 $j&amp;rsquo;$ 的范围为：
&lt;ul&gt;
&lt;li&gt;$0\le j&amp;rsquo;\le m&amp;rsquo;-i&#39;$&lt;/li&gt;
&lt;li&gt;$W&amp;rsquo;\le j&amp;rsquo;\le W&amp;rsquo;+m&amp;rsquo;-i&#39;$&lt;/li&gt;
&lt;li&gt;二者之一，可以结合前缀和 + &lt;code&gt;lower_bound&lt;/code&gt; 来快速求出答案。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;$B&amp;rsquo;&amp;gt;m&amp;rsquo;$ 与上面类似，不再赘述。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样就可完成快速的合并，而且似乎并不需要精细处理乘法爆 &lt;code&gt;long long&lt;/code&gt; 的情况。&lt;/p&gt;
&lt;h3 id=&#34;t4-下界最速移动&#34;&gt;T4 下界最速移动
&lt;/h3&gt;&lt;p&gt;给出一棵 $n$ 个点的树，节点编号从 $1$ 到 $n$，树边边权均为 $1$。&lt;/p&gt;
&lt;p&gt;给定树上的 $k$ 个关键点 $p_1,p_2,\cdots,p_k$，这 $k$ 个关键点两两之间添加一条边权为 $w$ 的无向边。&lt;/p&gt;
&lt;p&gt;求这个图的直径，以及取到直径的点对个数。&lt;/p&gt;
&lt;p&gt;$1\le T\le 10^3,2\le n\le 5\times 10^5,0\le k\le n,1\le w&amp;lt; n$，$\forall 1\le i&amp;lt;n,1\le f_i\le i$，$p_i$ 互不相同，且一个测试点中所有 $n$ 的和不超过 $8\times 10^5$。&lt;/p&gt;
&lt;h4 id=&#34;subtask-13-15pts&#34;&gt;Subtask 1~3 15pts
&lt;/h4&gt;&lt;p&gt;对 $1\le n\le 1000,\sum n\le 5000$ 的部分，观察到题目描述的图中的最短路可以描述为：
$$
dis_G(u,v)=\min(dis_T(u,v),d_u+d_v+w)
$$
其中 $dis_T$ 表示原树中两点间距离，$d_u$ 表示 $u$ 到最近一个关键点的树上距离。&lt;/p&gt;
&lt;p&gt;那么直接枚举所有点对进行统计即可，时间复杂度 $O(\sum n^2)$。&lt;/p&gt;
&lt;h4 id=&#34;subtask-46-15pts&#34;&gt;Subtask 4~6 15pts
&lt;/h4&gt;&lt;p&gt;对 $k\le 1$ 的部分，相当于没有新加的边，这时问题转化为求树的直径以及取到直径的点对个数。&lt;/p&gt;
&lt;p&gt;这有很多做法，包括换根 dp 等等。&lt;/p&gt;
&lt;p&gt;一个可行的做法是记 $dp[u],g[u]$ 分别表示 $u$ 到 $u$ 子树中的某个叶子的最大距离，以及取到这个距离的叶子个数，然后一个点统计在它的儿子中取两个所产生的贡献。&lt;/p&gt;
&lt;p&gt;时间复杂度 $O(\sum n)$。&lt;/p&gt;
&lt;h4 id=&#34;subtask-7-5pts&#34;&gt;Subtask 7 5pts
&lt;/h4&gt;&lt;p&gt;相当于形成了一个完全图，直接输出 $D=1,S=\binom n 2$ 即可。&lt;/p&gt;
&lt;h4 id=&#34;subtask-89-10pts&#34;&gt;Subtask 8~9 10pts
&lt;/h4&gt;&lt;p&gt;只求第一问，父节点随机。&lt;/p&gt;
&lt;p&gt;观察式子：
$$
dis_G(u,v)=\min(dis_T(u,v),d_u+d_v+w)
$$
其中出现了 $dis_T$，众所周知 $dis_T(u,v)=dep(u)+dep(v)-2\times dep(LCA(u,v))$，而这个 $dep$ 引导我们往这方面思考，因为随机父节点的情况下树高不高。&lt;/p&gt;
&lt;p&gt;为了最大化 $dis_G$，相同 $dep$ 的节点中我们一定会取 $d$ 值最大的那个，因此记 $dp[u][i]$ 表示 $u$ 子树中，$dep=i$ 的最大 $d$ 值，然后对一个节点 $u$，将它的儿子依次合并上，当合并一个儿子 $v$ 时，枚举 $v$ 中节点的深度 $j$，当前已合并到 $dp[u]$ 中的部分的节点深度 $k$，那么对答案的贡献为：
$$
\min(dp[v][j]+dp[u][k]+w,j+k-2\times dep(u))
$$
然后：
$$
dp[u][j]:=\max(dp[u][j],dp[v][j])
$$
这样做即可。&lt;/p&gt;
&lt;p&gt;期望时间复杂度 $O(\sum n\log^2n)$（期望树高 $\log n$）。&lt;/p&gt;
&lt;h4 id=&#34;subtask-1012-15pts&#34;&gt;Subtask 10~12 15pts
&lt;/h4&gt;&lt;p&gt;只求第一问，不限制树的形态。&lt;/p&gt;
&lt;p&gt;出现了 $dep$，那么我们就可以往长链剖分上想，记 $dp[u][i]$ 表示 $u$ 子树中，与 $u$ 的距离为 $i$ 的最大 $d$ 值，然后我们继承长儿子的信息，暴力合并短儿子的信息。令 $mxdep[u]$ 表示 $u$ 子树中最深的一个叶子与 $u$ 的距离。&lt;/p&gt;
&lt;p&gt;那么我们现在的问题就是在 $O(短链长度)$ 的时间内完成一条短链的贡献。&lt;/p&gt;
&lt;p&gt;令 $g[u][i]$ 表示 $u$ 子树中，与 $u$ 的距离至少为 $i$ 的最大 $d$ 值，容易发现随着 $i$ 的增大，$g[u][i]$ 的值减小。&lt;/p&gt;
&lt;p&gt;同时，以 $g[u][i]$ 代替 $dp[u][i]$ 并不会产生错误，那么我们可以将贡献改写为：
$$
\min(g[u][i]+g[v][j]+w,i+j+1)
$$
当我们枚举短链上的一个深度 $j$ 时，长链上 $g[u][i]$ 随 $i$ 增大而减小，因此用一次二分求出二者的分界点就可以了。最后还需要考虑一个端点在 $u$ 上的情况，这也可以通过一次二分来完成。&lt;/p&gt;
&lt;p&gt;时间复杂度 $O(\sum n\log n)$。&lt;/p&gt;
&lt;h4 id=&#34;subtask-1320-40pts&#34;&gt;Subtask 13~20 40pts
&lt;/h4&gt;&lt;p&gt;$1\le n\le10^5,\sum n\le 3\times 10^5$，需要求出第二问。&lt;/p&gt;
&lt;p&gt;首先先求出第一问的答案 $D$。&lt;/p&gt;
&lt;p&gt;然后相当于计数有多少对点对 $u,v$ 满足 $1\le u&amp;lt;v\le n,\min(dis_T(u,v),d_u+d_v+w)=D$。&lt;/p&gt;
&lt;p&gt;首先：
$$
\begin{aligned}
&amp;amp;\ \ \ \ \ \ \min(dis_T(u,v),d_u+d_v+w)=D\
&amp;amp;\Rightarrow
\begin{cases}
dis_T(u,v)\ge D\
d_u+d_v+w\ge D
\end{cases}
\end{aligned}
$$
同时，&lt;strong&gt;这两个条件至少有一个满足&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;考虑 dsu on tree，每个轻儿子中的点暴力枚举出来查询，分两种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$dis_T(u,v)=D$，$d_u+d_v+w\ge D$，枚举了一个轻子树中的点，另一个点在树上的范围可以表示为一段 dfn 区间，它的 $dep$  可以算出来，$d$ 的值是一个范围。&lt;/li&gt;
&lt;li&gt;$dis_T(u,v)&amp;gt;D$，$d_u+d_v+w= D$，枚举了一个轻子树中的点，另一个点在树上的范围可以表示为一段 dfn 区间，它的 $d$ 值可以算出来，$dep$ 的值是一个范围。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两种把询问记下来离线查一遍就可以做到 $O(n\log^2 n)$，其中一个 $\log$ 是由于 dsu 造成的，一个 $\log$ 是由于求后缀和造成的。&lt;/p&gt;
&lt;p&gt;具体来说，以第一种情况为例，当前节点为点 $x$，枚举了轻子树中的点 $v$ 之后可知：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应当有：&lt;code&gt;dep[u]=D+2*dep[x]-dep[v]&lt;/code&gt;， &lt;code&gt;d[u]&amp;gt;=D-d[v]-w&lt;/code&gt;， &lt;code&gt;u 在 v 之前的子树中&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;对于第三个条件，将重儿子 &lt;code&gt;swap&lt;/code&gt; 到遍历的第一个位置，那么相当于
&lt;code&gt;dfn[x]+1&amp;lt;=dfn[u]&amp;lt;dfn[v]&lt;/code&gt; 可以自己画图来进一步理解。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，点分治，边分治都可以在 $O(n\log^2 n)$ 的时间内解决这档问题，其原理与 dsu 类似。&lt;/p&gt;
&lt;p&gt;时间复杂度 $O(\sum n\log^2 n)$。&lt;/p&gt;
&lt;p&gt;为了控制难度把 2log 的做法放过去了，&lt;del&gt;敢写敢 AC&lt;/del&gt;，&lt;del&gt;存在 1log 的做法，实际写出来之后被 2log 爆杀，常数大到上天，仅作课后思考&lt;/del&gt;。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
