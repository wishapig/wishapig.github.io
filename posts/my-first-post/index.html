<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>My First Post | My New Hugo Site</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="T1 旅行 给出 $n$ 个点 $m$ 条边的有向图，点有点权，边有边权。
定义一条路径的权值为路径上点权的最大值乘上边权之和。
求出 $s$ 到 $t$ 的路径的最小权值，$q$ 组询问，若无法到达则输出 $-1$。
$1\le n\le 500,0\le m\le n\times(n-1),1\le q\le 10^4,1\le a_i,w\le 10^6,s_i\not=t_i$，保证图中不含重边与自环。
Subtask 1~6 30pts 直接搜索所有可能的路径，记录当前路径中点权最大值和边权之和。
注意到非简单路径一定是不优的，因此时间复杂度为 $O(n!)$，经过合适的剪枝似乎可以多跑过一个点。
Subtask 7~8 10pts 所有 $a_i$ 均为 $1$，这就表明了所有路径的点权最大值都是 $1$，此时只需要求出 $s$ 到 $t$ 的最短路径长度。
（不会有人真的做 $n$ 次 dij 吧）
Subtask ??? 使用各种神秘的最短路做法应该可以解决稀疏图和 $n\le 50$ 的情况，请各位充分发挥自己的想象力
Subtask 9~20 60pts 考虑使用 floyd 算法，一个常见的算法实现为：
for (int k=1; k&lt;=n; k&#43;&#43;){ for (int i=1; i&lt;=n; i&#43;&#43;) for (int j=1; j&lt;=n; j&#43;&#43;) dis[i][j]=min(dis[i][j],dis[i][k]&#43;dis[k][j]); } 其中 $k$ 每一轮做完之后，dis[i][j] 表示从 $i$ 到 $j$，只经过（不包含 $i,j$）编号 $\le k$ 的中间节点的最短路径长度。">
    <meta name="generator" content="Hugo 0.132.0">
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    

    
      

    

    

    
      <link rel="canonical" href="http://localhost:1313/posts/my-first-post/">
    

    <meta property="og:url" content="http://localhost:1313/posts/my-first-post/">
  <meta property="og:site_name" content="My New Hugo Site">
  <meta property="og:title" content="My First Post">
  <meta property="og:description" content="T1 旅行 给出 $n$ 个点 $m$ 条边的有向图，点有点权，边有边权。
定义一条路径的权值为路径上点权的最大值乘上边权之和。
求出 $s$ 到 $t$ 的路径的最小权值，$q$ 组询问，若无法到达则输出 $-1$。
$1\le n\le 500,0\le m\le n\times(n-1),1\le q\le 10^4,1\le a_i,w\le 10^6,s_i\not=t_i$，保证图中不含重边与自环。
Subtask 1~6 30pts 直接搜索所有可能的路径，记录当前路径中点权最大值和边权之和。
注意到非简单路径一定是不优的，因此时间复杂度为 $O(n!)$，经过合适的剪枝似乎可以多跑过一个点。
Subtask 7~8 10pts 所有 $a_i$ 均为 $1$，这就表明了所有路径的点权最大值都是 $1$，此时只需要求出 $s$ 到 $t$ 的最短路径长度。
（不会有人真的做 $n$ 次 dij 吧）
Subtask ??? 使用各种神秘的最短路做法应该可以解决稀疏图和 $n\le 50$ 的情况，请各位充分发挥自己的想象力
Subtask 9~20 60pts 考虑使用 floyd 算法，一个常见的算法实现为：
for (int k=1; k&lt;=n; k&#43;&#43;){ for (int i=1; i&lt;=n; i&#43;&#43;) for (int j=1; j&lt;=n; j&#43;&#43;) dis[i][j]=min(dis[i][j],dis[i][k]&#43;dis[k][j]); } 其中 $k$ 每一轮做完之后，dis[i][j] 表示从 $i$ 到 $j$，只经过（不包含 $i,j$）编号 $\le k$ 的中间节点的最短路径长度。">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-13T16:19:21+08:00">
    <meta property="article:modified_time" content="2024-08-13T16:19:21+08:00">

  <meta itemprop="name" content="My First Post">
  <meta itemprop="description" content="T1 旅行 给出 $n$ 个点 $m$ 条边的有向图，点有点权，边有边权。
定义一条路径的权值为路径上点权的最大值乘上边权之和。
求出 $s$ 到 $t$ 的路径的最小权值，$q$ 组询问，若无法到达则输出 $-1$。
$1\le n\le 500,0\le m\le n\times(n-1),1\le q\le 10^4,1\le a_i,w\le 10^6,s_i\not=t_i$，保证图中不含重边与自环。
Subtask 1~6 30pts 直接搜索所有可能的路径，记录当前路径中点权最大值和边权之和。
注意到非简单路径一定是不优的，因此时间复杂度为 $O(n!)$，经过合适的剪枝似乎可以多跑过一个点。
Subtask 7~8 10pts 所有 $a_i$ 均为 $1$，这就表明了所有路径的点权最大值都是 $1$，此时只需要求出 $s$ 到 $t$ 的最短路径长度。
（不会有人真的做 $n$ 次 dij 吧）
Subtask ??? 使用各种神秘的最短路做法应该可以解决稀疏图和 $n\le 50$ 的情况，请各位充分发挥自己的想象力
Subtask 9~20 60pts 考虑使用 floyd 算法，一个常见的算法实现为：
for (int k=1; k&lt;=n; k&#43;&#43;){ for (int i=1; i&lt;=n; i&#43;&#43;) for (int j=1; j&lt;=n; j&#43;&#43;) dis[i][j]=min(dis[i][j],dis[i][k]&#43;dis[k][j]); } 其中 $k$ 每一轮做完之后，dis[i][j] 表示从 $i$ 到 $j$，只经过（不包含 $i,j$）编号 $\le k$ 的中间节点的最短路径长度。">
  <meta itemprop="datePublished" content="2024-08-13T16:19:21+08:00">
  <meta itemprop="dateModified" content="2024-08-13T16:19:21+08:00">
  <meta itemprop="wordCount" content="788">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="My First Post">
  <meta name="twitter:description" content="T1 旅行 给出 $n$ 个点 $m$ 条边的有向图，点有点权，边有边权。
定义一条路径的权值为路径上点权的最大值乘上边权之和。
求出 $s$ 到 $t$ 的路径的最小权值，$q$ 组询问，若无法到达则输出 $-1$。
$1\le n\le 500,0\le m\le n\times(n-1),1\le q\le 10^4,1\le a_i,w\le 10^6,s_i\not=t_i$，保证图中不含重边与自环。
Subtask 1~6 30pts 直接搜索所有可能的路径，记录当前路径中点权最大值和边权之和。
注意到非简单路径一定是不优的，因此时间复杂度为 $O(n!)$，经过合适的剪枝似乎可以多跑过一个点。
Subtask 7~8 10pts 所有 $a_i$ 均为 $1$，这就表明了所有路径的点权最大值都是 $1$，此时只需要求出 $s$ 到 $t$ 的最短路径长度。
（不会有人真的做 $n$ 次 dij 吧）
Subtask ??? 使用各种神秘的最短路做法应该可以解决稀疏图和 $n\le 50$ 的情况，请各位充分发挥自己的想象力
Subtask 9~20 60pts 考虑使用 floyd 算法，一个常见的算法实现为：
for (int k=1; k&lt;=n; k&#43;&#43;){ for (int i=1; i&lt;=n; i&#43;&#43;) for (int j=1; j&lt;=n; j&#43;&#43;) dis[i][j]=min(dis[i][j],dis[i][k]&#43;dis[k][j]); } 其中 $k$ 每一轮做完之后，dis[i][j] 表示从 $i$ 到 $j$，只经过（不包含 $i,j$）编号 $\le k$ 的中间节点的最短路径长度。">

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        My New Hugo Site
      
    </a>
    <div class="flex-l items-center">
      

      
      
<div class="ananke-socials">
  
</div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Posts
      </aside>
      










  <div id="sharing" class="mt3 ananke-socials">
    
  </div>


      <h1 class="f1 athelas mt3 mb1">My First Post</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2024-08-13T16:19:21+08:00">August 13, 2024</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><h3 id="t1-旅行">T1 旅行</h3>
<p>给出 $n$ 个点 $m$ 条边的有向图，点有点权，边有边权。</p>
<p>定义一条路径的权值为路径上点权的最大值乘上边权之和。</p>
<p>求出 $s$ 到 $t$ 的路径的最小权值，$q$ 组询问，若无法到达则输出 $-1$。</p>
<p>$1\le n\le 500,0\le m\le n\times(n-1),1\le q\le 10^4,1\le a_i,w\le 10^6,s_i\not=t_i$，保证图中不含重边与自环。</p>
<h4 id="subtask-16-30pts">Subtask 1~6 30pts</h4>
<p>直接搜索所有可能的路径，记录当前路径中点权最大值和边权之和。</p>
<p>注意到非简单路径一定是不优的，因此时间复杂度为 $O(n!)$，经过合适的剪枝似乎可以多跑过一个点。</p>
<h4 id="subtask-78-10pts">Subtask 7~8 10pts</h4>
<p>所有 $a_i$ 均为 $1$，这就表明了所有路径的点权最大值都是 $1$，此时只需要求出 $s$ 到 $t$ 的最短路径长度。</p>
<p><del>（不会有人真的做 $n$ 次 dij 吧）</del></p>
<h4 id="subtask-">Subtask ???</h4>
<p>使用各种神秘的最短路做法应该可以解决稀疏图和 $n\le 50$ 的情况，<del>请各位充分发挥自己的想象力</del></p>
<h4 id="subtask-920-60pts">Subtask 9~20 60pts</h4>
<p>考虑使用 <code>floyd</code> 算法，一个常见的算法实现为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>; k<span style="color:#f92672">&lt;=</span>n; k<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>; i<span style="color:#f92672">&lt;=</span>n; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>; j<span style="color:#f92672">&lt;=</span>n; j<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>            dis[i][j]<span style="color:#f92672">=</span>min(dis[i][j],dis[i][k]<span style="color:#f92672">+</span>dis[k][j]);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>其中 $k$ 每一轮做完之后，<code>dis[i][j]</code> 表示从 $i$ 到 $j$，只经过（不包含 $i,j$）编号 $\le k$ 的中间节点的最短路径长度。</p>
<p>这里 $k$ 的枚举顺序可以进行调整，从而控制路径中间节点的一些信息。</p>
<p>因此考虑按点权从小到大的顺序枚举 $k$，那么<code>dis[i][j]</code> 表示从 $i$ 到 $j$，只经过（不包含 $i,j$）点权 $\le a[k]$ 的中间节点的最短路径长度，这也就相当于中间节点的点权 $\max\le a[k]$，问题就解决了。</p>
<h3 id="t2-极好的树">T2 极好的树</h3>
<p>定义一棵有根树是好的，当且仅当父节点编号小于子节点编号，且没有一棵子树的大小为给定的 $k$ 个数之一。求出 $n$ 个点的每种树高的好有根树个数，$\bmod (10^9+7)$。</p>
<p>$1\le T\le 5,0\le k&lt;n\le 500$，$1\le L\le R\le n$，$2\le a_1,a_2,\cdots a_k\le n$，且所有 $a_i$ 互不相同。</p>
<h4 id="subtask-15-25pts">Subtask 1~5 25pts</h4>
<p>由于每个点的父节点编号小于自身编号，可知节点 $1$ 一定为根节点以及 $fa_i&lt;i$，对每个 $i$ 枚举所有可能性，暴力所有树形进行统计即可。</p>
<h4 id="subtask-68-15pts">Subtask 6~8 15pts</h4>
<p>相当于求出树高 $h$ 分别为 $1,2,3$ 的答案。</p>
<ul>
<li>$h=1$ 当且仅当 $n=1$ 时有一个，其他没有。</li>
<li>$h=2$ 均有 $1$ 个（以 $1$ 为根的菊花）（需要满足无 $a_i=n$）。</li>
<li>$h=3$ 的情况，背包第二层的子树大小即可，但是注意到直接背包无法保证树高一定为 $3$，因此求出的实际上是树高 $\le 3$ 的答案，需要减去 $h=2$ 的答案。</li>
</ul>
<p>中间的部分分给的比较混沌，我不清楚是否有针对性的做法。</p>
<h4 id="subtask-920-60pts-1">Subtask 9~20 60pts</h4>
<p>根据上面部分分得到的启示，我们实际上无法很好地控制树高<strong>恰好</strong>为 $h$，我们可以控制的是树高<strong>不大于</strong> $h$，从这个方面进行思考，设 <code>dp[i][j]</code> 表示 $i$ 个节点的树高 $\le j$ 的好树个数，那么若 $i$ 出现在了给出的 $k$ 个数中，则 <code>dp[i][j]=0</code>。</p>
<p>那么显然 $1$ 号节点为根，对 $i=1$ 的情况，只有 <code>dp[1][1]=1</code>，对更大的 $i$，<strong>显然 $2$ 号节点为 $1$ 号节点的一个儿子</strong>。枚举 $2$ 号节点所处的子树的大小 $k$，可以得到转移如下：
$$
dp[k][j-1]\times dp[i-k][j]\times \binom{i-2}{k-1}\rightarrow dp[i][j]
$$
如果不枚举 $2$ 所在子树的大小，而是直接 $\Large\binom{i-1}{k}$ 的话会算重。</p>
<p>其意义为：</p>
<p>组合数 $\Large\binom{i-2}{k-1}$ 为从编号 $3,4,\cdots ,i$ 中取出 $k-1$ 个作为 $2$ 子树中的节点的编号。</p>
<p><code>dp[k][j-1]</code> 则显然是枚举了 $2$ 所处的子树大小 $k$，同时这棵子树的树高应当 $\le j-1$。</p>
<p><code>dp[i-k][j]</code> 是去掉了 $2$ 的子树的剩余部分，这部分可以作为一个子问题，继续枚举其中编号最小的儿子，同时这部分的树高应当 $\le j$。</p>
<p>最终树高为 $h$ 的答案即为 <code>dp[n][h]-dp[n][h-1]</code>。</p>
<hr>
<p>另外，可以使用卷积将复杂度优化至 $O(n^2\log n)$，但在 NOIP 范围内意义不大了。</p>
<h3 id="t3-约束">T3 约束</h3>
<ul>
<li>$0\le x\le m$</li>
<li>$x\not \equiv b_i \pmod {a_i}$，对任意 $1\le i\le n$ 成立</li>
</ul>
<p>求出满足条件的 $x$ 的个数。</p>
<p>$1\le n\le 100,0\le m\le 10^{18},2\le a_i\le 31,0\le b_i&lt;a_i$，所有 $a_i$ 均为质数。</p>
<h4 id="subtask-14-20pts">Subtask 1~4 20pts</h4>
<p>直接枚举即可</p>
<h4 id="subtask-58-20pts">Subtask 5~8 20pts</h4>
<p>考虑容斥，钦定若干组 $(a_i,b_i)$ 要求 $x\equiv b_i\pmod {a_i}$，其余无所谓。</p>
<p>由于所有 $a_i$ 互不相同，因此限制至多只有 $11$ 组，可以暴力 $2^{11}$ 枚举所有钦定的情况。</p>
<p>那么现在问题就是：<del>CRT 还记得吗</del>。</p>
<p>这里我们尝试两两合并同余式：
$$
\begin{aligned}
&amp;a&rsquo;=a_1a_2\
&amp;b&rsquo;=(b_1\times a_2\times (a_2^{-1}\bmod a_1)+b_2\times a_1\times (a_1^{-1}\bmod a_2))\pmod {a&rsquo;}
\end{aligned}
$$
然后就可以将钦定的所有同余式合并起来得到 $x\equiv B\pmod A$，求出 $0\sim m$ 中满足这个条件的个数是容易的，记得乘上容斥系数 $(-1)^{|S|}$。</p>
<p>你可能需要比较细心的实现，防止乘法爆 <code>long long</code>。</p>
<h4 id="subtask-913-25pts">Subtask 9~13 25pts</h4>
<p>这里不保证 $a_i$ 互不相同了，也就是说同一个 $a_i$ 可以对应多个 $b_i$，钦定的所有 $(a_i,b_i)$ 中 $a_i$ 一定互不相同（注意 <code>pair(a[i],b[i])</code> 可能是相同的，此时需要去重，否则会重复计算）。</p>
<p>此时仍然沿用上面的容斥思路是没有问题的，但是不能暴力枚举所有钦定的情况。</p>
<p>所以考虑 <code>dp</code>，按<strong>每种</strong> $a_i$ 进行 <code>dp</code>，注意到 $2\times 3\times 5\times 7\times 11\times 13\times 17=510510$，所以可以直接把合并得到的同余式中的 $B$ 作为状态存下来。</p>
<p>设 <code>dp[i][j]</code> 表示决策完前 $i$ 种模数，获得的同余式 $x\equiv j\pmod {L_i}$ 的答案，其中 $L_i$ 为前 $i$ 个质数的乘积，也就是合并得到的同余式的模数。</p>
<p>对于一种 $a_i$，枚举钦定了哪一组 $(a_t,b_t)$ 违反了，然后进行转移：
$$
dp[i][j]\times (-1)\rightarrow dp[i+1][\operatorname{trans}(j,L_i,b_t,a_t)]
$$
其中 <code>trans</code> 就是合并完两个同余式之后得到的 $B$。</p>
<p>特殊地，如果一个质数没有钦定它违反任何一组，那么其实也需要更新（设 $P_i$ 为第 $i$ 个质数）：
$$
dp[i][j]\rightarrow dp[i+1][L_i\times t+j](0\le t&lt;P_{i+1})
$$
这样就可以进行 <code>dp</code> 了。</p>
<h4 id="subtask-1420-35pts">Subtask 14~20 35pts</h4>
<p>尝试沿用上面的思路，但 $2\times3\times5\times7\times11\times13\times17\times19\times23\times29\times31=200560490130$，所以直接把 $B$ 塞到状态里显然是做不到了。</p>
<p>所以可以使用 meet in the middle，将 $11$ 种模数分成 $2,3,5,7,11,13,17$ 和 $19,23,29,31$ 两组，第一组的积为 $510510$，第二组的积为 $392863$，可以两组单独做，然后试试将它们合并起来。</p>
<p>首先设左右两组的 <code>dp</code> 已经全部完成，得到 <code>dpL</code>，<code>dpR</code>，并设 $W_1,W_2$ 分别为左右两组质数的积。</p>
<p>那么如果左右两侧分别枚举 $i,j$，那么合并结果应当为：
$$
\begin{aligned}
&amp;W&rsquo;=W_1W_2\
&amp;B&rsquo;=(i\times W_2\times (W_2^{-1}\bmod W_1)+j\times W_1\times (W_1^{-1}\bmod W_2))\pmod {W&rsquo;}
\end{aligned}
$$
同时贡献为 <code>dpL[i]*dpR[j]</code>。</p>
<p>这里的 $W_2\times (W_2^{-1}\bmod W_1)$ 和 $W_1\times (W_1^{-1}\bmod W_2)$ 都是常数，设为 $X,Y$，那么
$$
B&rsquo;=(i\times X+j\times Y)\bmod {W&rsquo;}
$$
还是不够简洁！设 $i&rsquo;=i\times X\bmod W&rsquo;,j&rsquo;=j\times Y\bmod W&rsquo;$，那么
$$
B&rsquo;=(i&rsquo;+j&rsquo;)\bmod W'
$$
由于 $0\sim m$ 中满足 $x\equiv B\pmod A$ 的 $x$ 个数要么为 $\lfloor m/A\rfloor$ 要么为 $\lfloor m/A\rfloor+1$，区分依据就是 $B$ 和 $m\bmod A$ 的大小关系，因此考虑分讨这两种情况，方便起见，令 $m&rsquo;=m\bmod W&rsquo;$。</p>
<ul>
<li>$B&rsquo;\le m&rsquo;$，此时为 $\lfloor m/A\rfloor+1$ 次，这种情况，先枚举一个 $i&rsquo;$，那么合法的 $j&rsquo;$ 的范围为：
<ul>
<li>$0\le j&rsquo;\le m&rsquo;-i'$</li>
<li>$W&rsquo;\le j&rsquo;\le W&rsquo;+m&rsquo;-i'$</li>
<li>二者之一，可以结合前缀和 + <code>lower_bound</code> 来快速求出答案。</li>
</ul>
</li>
<li>$B&rsquo;&gt;m&rsquo;$ 与上面类似，不再赘述。</li>
</ul>
<p>这样就可完成快速的合并，而且似乎并不需要精细处理乘法爆 <code>long long</code> 的情况。</p>
<h3 id="t4-下界最速移动">T4 下界最速移动</h3>
<p>给出一棵 $n$ 个点的树，节点编号从 $1$ 到 $n$，树边边权均为 $1$。</p>
<p>给定树上的 $k$ 个关键点 $p_1,p_2,\cdots,p_k$，这 $k$ 个关键点两两之间添加一条边权为 $w$ 的无向边。</p>
<p>求这个图的直径，以及取到直径的点对个数。</p>
<p>$1\le T\le 10^3,2\le n\le 5\times 10^5,0\le k\le n,1\le w&lt; n$，$\forall 1\le i&lt;n,1\le f_i\le i$，$p_i$ 互不相同，且一个测试点中所有 $n$ 的和不超过 $8\times 10^5$。</p>
<h4 id="subtask-13-15pts">Subtask 1~3 15pts</h4>
<p>对 $1\le n\le 1000,\sum n\le 5000$ 的部分，观察到题目描述的图中的最短路可以描述为：
$$
dis_G(u,v)=\min(dis_T(u,v),d_u+d_v+w)
$$
其中 $dis_T$ 表示原树中两点间距离，$d_u$ 表示 $u$ 到最近一个关键点的树上距离。</p>
<p>那么直接枚举所有点对进行统计即可，时间复杂度 $O(\sum n^2)$。</p>
<h4 id="subtask-46-15pts">Subtask 4~6 15pts</h4>
<p>对 $k\le 1$ 的部分，相当于没有新加的边，这时问题转化为求树的直径以及取到直径的点对个数。</p>
<p>这有很多做法，包括换根 dp 等等。</p>
<p>一个可行的做法是记 $dp[u],g[u]$ 分别表示 $u$ 到 $u$ 子树中的某个叶子的最大距离，以及取到这个距离的叶子个数，然后一个点统计在它的儿子中取两个所产生的贡献。</p>
<p>时间复杂度 $O(\sum n)$。</p>
<h4 id="subtask-7-5pts">Subtask 7 5pts</h4>
<p>相当于形成了一个完全图，直接输出 $D=1,S=\binom n 2$ 即可。</p>
<h4 id="subtask-89-10pts">Subtask 8~9 10pts</h4>
<p>只求第一问，父节点随机。</p>
<p>观察式子：
$$
dis_G(u,v)=\min(dis_T(u,v),d_u+d_v+w)
$$
其中出现了 $dis_T$，众所周知 $dis_T(u,v)=dep(u)+dep(v)-2\times dep(LCA(u,v))$，而这个 $dep$ 引导我们往这方面思考，因为随机父节点的情况下树高不高。</p>
<p>为了最大化 $dis_G$，相同 $dep$ 的节点中我们一定会取 $d$ 值最大的那个，因此记 $dp[u][i]$ 表示 $u$ 子树中，$dep=i$ 的最大 $d$ 值，然后对一个节点 $u$，将它的儿子依次合并上，当合并一个儿子 $v$ 时，枚举 $v$ 中节点的深度 $j$，当前已合并到 $dp[u]$ 中的部分的节点深度 $k$，那么对答案的贡献为：
$$
\min(dp[v][j]+dp[u][k]+w,j+k-2\times dep(u))
$$
然后：
$$
dp[u][j]:=\max(dp[u][j],dp[v][j])
$$
这样做即可。</p>
<p>期望时间复杂度 $O(\sum n\log^2n)$（期望树高 $\log n$）。</p>
<h4 id="subtask-1012-15pts">Subtask 10~12 15pts</h4>
<p>只求第一问，不限制树的形态。</p>
<p>出现了 $dep$，那么我们就可以往长链剖分上想，记 $dp[u][i]$ 表示 $u$ 子树中，与 $u$ 的距离为 $i$ 的最大 $d$ 值，然后我们继承长儿子的信息，暴力合并短儿子的信息。令 $mxdep[u]$ 表示 $u$ 子树中最深的一个叶子与 $u$ 的距离。</p>
<p>那么我们现在的问题就是在 $O(短链长度)$ 的时间内完成一条短链的贡献。</p>
<p>令 $g[u][i]$ 表示 $u$ 子树中，与 $u$ 的距离至少为 $i$ 的最大 $d$ 值，容易发现随着 $i$ 的增大，$g[u][i]$ 的值减小。</p>
<p>同时，以 $g[u][i]$ 代替 $dp[u][i]$ 并不会产生错误，那么我们可以将贡献改写为：
$$
\min(g[u][i]+g[v][j]+w,i+j+1)
$$
当我们枚举短链上的一个深度 $j$ 时，长链上 $g[u][i]$ 随 $i$ 增大而减小，因此用一次二分求出二者的分界点就可以了。最后还需要考虑一个端点在 $u$ 上的情况，这也可以通过一次二分来完成。</p>
<p>时间复杂度 $O(\sum n\log n)$。</p>
<h4 id="subtask-1320-40pts">Subtask 13~20 40pts</h4>
<p>$1\le n\le10^5,\sum n\le 3\times 10^5$，需要求出第二问。</p>
<p>首先先求出第一问的答案 $D$。</p>
<p>然后相当于计数有多少对点对 $u,v$ 满足 $1\le u&lt;v\le n,\min(dis_T(u,v),d_u+d_v+w)=D$。</p>
<p>首先：
$$
\begin{aligned}
&amp;\ \ \ \ \ \ \min(dis_T(u,v),d_u+d_v+w)=D\
&amp;\Rightarrow
\begin{cases}
dis_T(u,v)\ge D\
d_u+d_v+w\ge D
\end{cases}
\end{aligned}
$$
同时，<strong>这两个条件至少有一个满足</strong>。</p>
<p>考虑 dsu on tree，每个轻儿子中的点暴力枚举出来查询，分两种情况：</p>
<ul>
<li>$dis_T(u,v)=D$，$d_u+d_v+w\ge D$，枚举了一个轻子树中的点，另一个点在树上的范围可以表示为一段 dfn 区间，它的 $dep$  可以算出来，$d$ 的值是一个范围。</li>
<li>$dis_T(u,v)&gt;D$，$d_u+d_v+w= D$，枚举了一个轻子树中的点，另一个点在树上的范围可以表示为一段 dfn 区间，它的 $d$ 值可以算出来，$dep$ 的值是一个范围。</li>
</ul>
<p>这两种把询问记下来离线查一遍就可以做到 $O(n\log^2 n)$，其中一个 $\log$ 是由于 dsu 造成的，一个 $\log$ 是由于求后缀和造成的。</p>
<p>具体来说，以第一种情况为例，当前节点为点 $x$，枚举了轻子树中的点 $v$ 之后可知：</p>
<ul>
<li>应当有：<code>dep[u]=D+2*dep[x]-dep[v]</code>， <code>d[u]&gt;=D-d[v]-w</code>， <code>u 在 v 之前的子树中</code></li>
<li>对于第三个条件，将重儿子 <code>swap</code> 到遍历的第一个位置，那么相当于
<code>dfn[x]+1&lt;=dfn[u]&lt;dfn[v]</code> 可以自己画图来进一步理解。</li>
</ul>
<p>另外，点分治，边分治都可以在 $O(n\log^2 n)$ 的时间内解决这档问题，其原理与 dsu 类似。</p>
<p>时间复杂度 $O(\sum n\log^2 n)$。</p>
<p>为了控制难度把 2log 的做法放过去了，<del>敢写敢 AC</del>，<del>存在 1log 的做法，实际写出来之后被 2log 爆杀，常数大到上天，仅作课后思考</del>。</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://localhost:1313/" >
    &copy;  My New Hugo Site 2024 
  </a>
    <div>
<div class="ananke-socials">
  
</div>
</div>
  </div>
</footer>

  </body>
</html>
